---
description: Integrasi Firebase services untuk Flutter: Authentication, Cloud Firestore, Firebase Storage, dan Firebase Cloud Mess... (Part 2/4)
---
# Workflow: Firebase Integration (Part 2/4)

> **Navigation:** This workflow is split into 4 parts.

## Deliverables

### 1. Firebase Project Setup

**Description:** Setup Firebase project dan konfigurasi Flutter app.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Install FlutterFire CLI:**
   ```bash
   dart pub global activate flutterfire_cli
   ```

2. **Configure Firebase:**
   ```bash
   flutterfire configure
   ```

3. **Add Dependencies:** (Updated untuk Flutter 3.41.1)
   ```yaml
   dependencies:
     firebase_core: ^3.12.0
     firebase_auth: ^5.5.0
     cloud_firestore: ^5.6.0
     firebase_storage: ^12.4.0
     firebase_messaging: ^15.2.0
   ```

4. **Initialize Firebase:**
   ```dart
   // bootstrap/bootstrap.dart
   import 'package:firebase_core/firebase_core.dart';
   import 'firebase_options.dart';
   
   Future<void> bootstrap() async {
     WidgetsFlutterBinding.ensureInitialized();
     
     await Firebase.initializeApp(
       options: DefaultFirebaseOptions.currentPlatform,
     );
     
     runApp(const ProviderScope(child: MyApp()));
   }
   ```

**Output Format:**
```dart
// lib/firebase_options.dart (auto-generated by FlutterFire)
// This file is generated - do not edit manually

import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;

class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      default:
        throw UnsupportedError('Unsupported platform');
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'YOUR_API_KEY',
    appId: 'YOUR_APP_ID',
    messagingSenderId: 'YOUR_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_BUCKET',
  );
  
  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'YOUR_API_KEY',
    appId: 'YOUR_APP_ID',
    messagingSenderId: 'YOUR_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_BUCKET',
    iosClientId: 'YOUR_IOS_CLIENT_ID',
    iosBundleId: 'YOUR_BUNDLE_ID',
  );
}
```

---

## Deliverables

### 2. Firebase Authentication

**Description:** Implementasi Firebase Auth dengan email/password, Google Sign-In, dan state management.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Setup Auth Service:**
   - Email/password authentication
   - Google Sign-In
   - Auth state stream
   - Logout functionality

2. **Auth Repository:**
   - Abstract contract
   - Firebase implementation
   - Error handling

3. **Auth Controller:**
   - Riverpod controller untuk auth state
   - Login/logout methods
   - Auth state persistence

**Output Format:**
```dart
// features/auth/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Stream<User?> get authStateChanges;
  Future<Either<Failure, User>> signInWithEmailAndPassword(String email, String password);
  Future<Either<Failure, User>> signInWithGoogle();
  Future<Either<Failure, User>> signUp(String email, String password);
  Future<Either<Failure, Unit>> signOut();
  User? get currentUser;
}

// features/auth/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final FirebaseAuth _firebaseAuth;
  final GoogleSignIn _googleSignIn;
  
  AuthRepositoryImpl({
    FirebaseAuth? firebaseAuth,
    GoogleSignIn? googleSignIn,
  })  : _firebaseAuth = firebaseAuth ?? FirebaseAuth.instance,
        _googleSignIn = googleSignIn ?? GoogleSignIn();
  
  @override
  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();
  
  @override
  Future<Either<Failure, User>> signInWithEmailAndPassword(
    String email,
    String password,
  ) async {
    try {
      final result = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (result.user == null) {
        return const Left(AuthFailure('User not found'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, User>> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      if (googleUser == null) {
        return const Left(AuthFailure('Google sign-in cancelled'));
      }
      
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );
      
      final result = await _firebaseAuth.signInWithCredential(credential);
      
      if (result.user == null) {
        return const Left(AuthFailure('Failed to sign in with Google'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, User>> signUp(String email, String password) async {
    try {
      final result = await _firebaseAuth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (result.user == null) {
        return const Left(AuthFailure('Failed to create user'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, Unit>> signOut() async {
    try {
      await Future.wait([
        _firebaseAuth.signOut(),
        _googleSignIn.signOut(),
      ]);
      return const Right(unit);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  User? get currentUser => _firebaseAuth.currentUser;
  
  Failure _mapAuthError(FirebaseAuthException e) {
    switch (e.code) {
      case 'user-not-found':
        return const AuthFailure('No user found with this email');
      case 'wrong-password':
        return const AuthFailure('Incorrect password');
      case 'email-already-in-use':
        return const AuthFailure('Email is already registered');
      case 'invalid-email':
        return const AuthFailure('Invalid email address');
      case 'weak-password':
        return const AuthFailure('Password is too weak');
      default:
        return AuthFailure(e.message ?? 'Authentication error');
    }
  }
}

// features/auth/presentation/controllers/auth_controller.dart
@riverpod
class AuthController extends _$AuthController {
  @override
  Stream<User?> build() {
    final repository = ref.watch(authRepositoryProvider);
    return repository.authStateChanges;
  }
  
  Future<void> signInWithEmailAndPassword(String email, String password) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final result = await repository.signInWithEmailAndPassword(email, password);
      return result.fold(
        (failure) => throw failure,
        (user) => user,
      );
    });
  }
  
  Future<void> signInWithGoogle() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final result = await repository.signInWithGoogle();
      return result.fold(
        (failure) => throw failure,
        (user) => user,
      );
    });
  }
  
  Future<void> signOut() async {
    final repository = ref.read(authRepositoryProvider);
    await repository.signOut();
  }
}
```

---

