---
description: Pada workflow ini, kita akan menambahkan **comprehensive testing suite** dan **production deployment pipeline** untuk... (Part 3/7)
---
# Workflow 07: Testing & Production Deployment (Part 3/7)

> **Navigation:** This workflow is split into 7 parts.

## Deliverables

### 2. Mocking dengan Testify/Mock

Generate dan gunakan mocks untuk repository layer.

```go
// internal/mocks/user_repository_mock.go
package mocks

import (
	"context"

	"github.com/stretchr/testify/mock"

	"myapp/internal/domain"
)

// UserRepository is an autogenerated mock type for the UserRepository type
type UserRepository struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, user
func (_m *UserRepository) Create(ctx context.Context, user *domain.User) error {
	ret := _m.Called(ctx, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *UserRepository) GetByID(ctx context.Context, id int64) (*domain.User, error) {
	ret := _m.Called(ctx, id)

	var r0 *domain.User
	if rf, ok := ret.Get(0).(func(context.Context, int64) *domain.User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByEmail provides a mock function with given fields: ctx, email
func (_m *UserRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	ret := _m.Called(ctx, email)

	var r0 *domain.User
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, user
func (_m *UserRepository) Update(ctx context.Context, user *domain.User) error {
	ret := _m.Called(ctx, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, id
func (_m *UserRepository) Delete(ctx context.Context, id int64) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: ctx, offset, limit
func (_m *UserRepository) List(ctx context.Context, offset, limit int) ([]*domain.User, error) {
	ret := _m.Called(ctx, offset, limit)

	var r0 []*domain.User
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []*domain.User); ok {
		r0 = rf(ctx, offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, offset, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewUserRepository creates a new instance of UserRepository
func NewUserRepository() *UserRepository {
	return &UserRepository{}
}
```

```go
// internal/mocks/mock.go
package mocks

// Config interface for testing
type Config interface {
	GetJWTSecret() string
	GetJWTExpiration() int
	GetBcryptCost() int
}

// testConfig implements Config for testing
type testConfig struct{}

func (t *testConfig) GetJWTSecret() string {
	return "test-secret-key-for-unit-tests-only"
}

func (t *testConfig) GetJWTExpiration() int {
	return 24
}

func (t *testConfig) GetBcryptCost() int {
	return 10
}
```

## Deliverables

### 3. Integration Testing

Integration tests menggunakan test database dengan Docker.

```go
// internal/repository/user_repository_test.go
package repository

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"os"
	"testing"

	"github.com/ory/dockertest/v3"
	"github.com/ory/dockertest/v3/docker"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"github.com/uptrace/bun"
	"github.com/uptrace/bun/dialect/pgdialect"
	"github.com/uptrace/bun/driver/pgdriver"

	"myapp/internal/domain"
)

type UserRepositoryTestSuite struct {
	suite.Suite
	DB         *bun.DB
	pool       *dockertest.Pool
	resource   *dockertest.Resource
	repository UserRepository
}

func (suite *UserRepositoryTestSuite) SetupSuite() {
	// Setup Docker pool
	pool, err := dockertest.NewPool("")
	if err != nil {
		log.Fatalf("Could not construct pool: %s", err)
	}
	suite.pool = pool

	// Setup PostgreSQL container
	resource, err := pool.RunWithOptions(&dockertest.RunOptions{
		Repository: "postgres",
		Tag:        "16-alpine",
		Env: []string{
			"POSTGRES_USER=testuser",
			"POSTGRES_PASSWORD=testpass",
			"POSTGRES_DB=testdb",
			"listen_addresses = '*'",
		},
	}, func(config *docker.HostConfig) {
		config.AutoRemove = true
		config.RestartPolicy = docker.RestartPolicy{Name: "no"}
	})
	if err != nil {
		log.Fatalf("Could not start resource: %s", err)
	}
	suite.resource = resource

	// Get host and port
	hostAndPort := resource.GetHostPort("5432/tcp")
	databaseUrl := fmt.Sprintf("postgres://testuser:testpass@%s/testdb?sslmode=disable", hostAndPort)

	// Wait for database to be ready
	if err := pool.Retry(func() error {
		var err error
		sqlDB := sql.OpenDB(pgdriver.NewConnector(pgdriver.WithDSN(databaseUrl)))
		return sqlDB.Ping()
	}); err != nil {
		log.Fatalf("Could not connect to database: %s", err)
	}

	// Create bun.DB instance
	sqlDB := sql.OpenDB(pgdriver.NewConnector(pgdriver.WithDSN(databaseUrl)))
	suite.DB = bun.NewDB(sqlDB, pgdialect.New())

	// Run migrations
	suite.runMigrations()

	// Create repository
	suite.repository = NewUserRepository(suite.DB)
}

func (suite *UserRepositoryTestSuite) TearDownSuite() {
	// Cleanup
	if err := suite.pool.Purge(suite.resource); err != nil {
		log.Fatalf("Could not purge resource: %s", err)
	}
}

func (suite *UserRepositoryTestSuite) SetupTest() {
	// Clear data before each test
	ctx := context.Background()
	_, err := suite.DB.NewDelete().Model((*domain.User)(nil)).Where("1=1").Exec(ctx)
	if err != nil {
		log.Printf("Failed to clear test data: %v", err)
	}
}

func (suite *UserRepositoryTestSuite) runMigrations() {
	ctx := context.Background()
	
	// Create users table
	_, err := suite.DB.ExecContext(ctx, `
		CREATE TABLE IF NOT EXISTS users (
			id SERIAL PRIMARY KEY,
			name VARCHAR(255) NOT NULL,
			email VARCHAR(255) UNIQUE NOT NULL,
			password_hash VARCHAR(255) NOT NULL,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)
	`)
	if err != nil {
		log.Fatalf("Failed to run migrations: %s", err)
	}
}

func (suite *UserRepositoryTestSuite) TestCreate() {
	ctx := context.Background()

	user := &domain.User{
		Name:         "Test User",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
	}

	err := suite.repository.Create(ctx, user)

	assert.NoError(suite.T(), err)
	assert.NotZero(suite.T(), user.ID)
	assert.NotZero(suite.T(), user.CreatedAt)
	assert.NotZero(suite.T(), user.UpdatedAt)
}

func (suite *UserRepositoryTestSuite) TestCreate_DuplicateEmail() {
	ctx := context.Background()

	// Create first user
	user1 := &domain.User{
		Name:         "User One",
		Email:        "duplicate@example.com",
		PasswordHash: "hash1",
	}
	err := suite.repository.Create(ctx, user1)
	assert.NoError(suite.T(), err)

	// Try to create second user with same email
	user2 := &domain.User{
		Name:         "User Two",
		Email:        "duplicate@example.com",
		PasswordHash: "hash2",
	}
	err = suite.repository.Create(ctx, user2)

	assert.Error(suite.T(), err)
	assert.Contains(suite.T(), err.Error(), "duplicate")
}

func (suite *UserRepositoryTestSuite) TestGetByID() {
	ctx := context.Background()

	// Create test user
	user := &domain.User{
		Name:         "Test User",
		Email:        "getbyid@example.com",
		PasswordHash: "hash",
	}
	err := suite.repository.Create(ctx, user)
	assert.NoError(suite.T(), err)

	// Get user by ID
	found, err := suite.repository.GetByID(ctx, user.ID)

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), found)
	assert.Equal(suite.T(), user.ID, found.ID)
	assert.Equal(suite.T(), user.Name, found.Name)
	assert.Equal(suite.T(), user.Email, found.Email)
}

func (suite *UserRepositoryTestSuite) TestGetByID_NotFound() {
	ctx := context.Background()

	// Try to get non-existent user
	found, err := suite.repository.GetByID(ctx, 99999)

	assert.NoError(suite.T(), err)
	assert.Nil(suite.T(), found)
}

func (suite *UserRepositoryTestSuite) TestGetByEmail() {
	ctx := context.Background()

	// Create test user
	user := &domain.User{
		Name:         "Test User",
		Email:        "getbyemail@example.com",
		PasswordHash: "hash",
	}
	err := suite.repository.Create(ctx, user)
	assert.NoError(suite.T(), err)

	// Get user by email
	found, err := suite.repository.GetByEmail(ctx, "getbyemail@example.com")

	assert.NoError(suite.T(), err)
	assert.NotNil(suite.T(), found)
	assert.Equal(suite.T(), user.ID, found.ID)
}

func (suite *UserRepositoryTestSuite) TestUpdate() {
	ctx := context.Background()

	// Create test user
	user := &domain.User{
		Name:         "Original Name",
		Email:        "update@example.com",
		PasswordHash: "hash",
	}
	err := suite.repository.Create(ctx, user)
	assert.NoError(suite.T(), err)

	// Update user
	user.Name = "Updated Name"
	err = suite.repository.Update(ctx, user)

	assert.NoError(suite.T(), err)

	// Verify update
	found, err := suite.repository.GetByID(ctx, user.ID)
	assert.NoError(suite.T(), err)
	assert.Equal(suite.T(), "Updated Name", found.Name)
}

func (suite *UserRepositoryTestSuite) TestDelete() {
	ctx := context.Background()

	// Create test user
	user := &domain.User{
		Name:         "Test User",
		Email:        "delete@example.com",
		PasswordHash: "hash",
	}
	err := suite.repository.Create(ctx, user)
	assert.NoError(suite.T(), err)

	// Delete user
	err = suite.repository.Delete(ctx, user.ID)
	assert.NoError(suite.T(), err)

	// Verify deletion
	found, err := suite.repository.GetByID(ctx, user.ID)
	assert.NoError(suite.T(), err)
	assert.Nil(suite.T(), found)
}

func (suite *UserRepositoryTestSuite) TestList() {
	ctx := context.Background()

	// Create multiple users
	for i := 1; i <= 5; i++ {
		user := &domain.User{
			Name:         fmt.Sprintf("User %d", i),
			Email:        fmt.Sprintf("user%d@example.com", i),
			PasswordHash: "hash",
		}
		err := suite.repository.Create(ctx, user)
		assert.NoError(suite.T(), err)
	}

	// Test list with pagination
	users, err := suite.repository.List(ctx, 0, 3)

	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), users, 3)

	// Test second page
	users, err = suite.repository.List(ctx, 3, 3)

	assert.NoError(suite.T(), err)
	assert.Len(suite.T(), users, 2)
}

func TestUserRepositoryTestSuite(t *testing.T) {
	if os.Getenv("SKIP_INTEGRATION_TESTS") != "" {
		t.Skip("Skipping integration tests")
	}
	suite.Run(t, new(UserRepositoryTestSuite))
}
```

