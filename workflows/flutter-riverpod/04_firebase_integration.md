# Workflow: Firebase Integration

## Overview

Integrasi Firebase services untuk Flutter: Authentication, Cloud Firestore, Firebase Storage, dan Firebase Cloud Messaging (FCM). Workflow ini mencakup setup lengkap dan best practices.

## Output Location

**Base Folder:** `sdlc/flutter-riverpod/04-firebase-integration/`

**Output Files:**
- `firebase-setup.md` - Setup Firebase project dan Flutter
- `auth/` - Authentication implementation
- `firestore/` - Database CRUD operations
- `storage/` - File upload/download
- `fcm/` - Push notifications
- `security/` - Security rules dan best practices
- `examples/` - Contoh implementasi lengkap

## Prerequisites

- Project setup dari `01_project_setup.md` selesai
- Firebase account (firebase.google.com)
- FlutterFire CLI terinstall

## Deliverables

### 1. Firebase Project Setup

**Description:** Setup Firebase project dan konfigurasi Flutter app.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Install FlutterFire CLI:**
   ```bash
   dart pub global activate flutterfire_cli
   ```

2. **Configure Firebase:**
   ```bash
   flutterfire configure
   ```

3. **Add Dependencies:** (Updated untuk Flutter 3.41.1)
   ```yaml
   dependencies:
     firebase_core: ^3.12.0
     firebase_auth: ^5.5.0
     cloud_firestore: ^5.6.0
     firebase_storage: ^12.4.0
     firebase_messaging: ^15.2.0
   ```

4. **Initialize Firebase:**
   ```dart
   // bootstrap/bootstrap.dart
   import 'package:firebase_core/firebase_core.dart';
   import 'firebase_options.dart';
   
   Future<void> bootstrap() async {
     WidgetsFlutterBinding.ensureInitialized();
     
     await Firebase.initializeApp(
       options: DefaultFirebaseOptions.currentPlatform,
     );
     
     runApp(const ProviderScope(child: MyApp()));
   }
   ```

**Output Format:**
```dart
// lib/firebase_options.dart (auto-generated by FlutterFire)
// This file is generated - do not edit manually

import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;

class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      default:
        throw UnsupportedError('Unsupported platform');
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'YOUR_API_KEY',
    appId: 'YOUR_APP_ID',
    messagingSenderId: 'YOUR_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_BUCKET',
  );
  
  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'YOUR_API_KEY',
    appId: 'YOUR_APP_ID',
    messagingSenderId: 'YOUR_SENDER_ID',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_BUCKET',
    iosClientId: 'YOUR_IOS_CLIENT_ID',
    iosBundleId: 'YOUR_BUNDLE_ID',
  );
}
```

---

### 2. Firebase Authentication

**Description:** Implementasi Firebase Auth dengan email/password, Google Sign-In, dan state management.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Setup Auth Service:**
   - Email/password authentication
   - Google Sign-In
   - Auth state stream
   - Logout functionality

2. **Auth Repository:**
   - Abstract contract
   - Firebase implementation
   - Error handling

3. **Auth Controller:**
   - Riverpod controller untuk auth state
   - Login/logout methods
   - Auth state persistence

**Output Format:**
```dart
// features/auth/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Stream<User?> get authStateChanges;
  Future<Either<Failure, User>> signInWithEmailAndPassword(String email, String password);
  Future<Either<Failure, User>> signInWithGoogle();
  Future<Either<Failure, User>> signUp(String email, String password);
  Future<Either<Failure, Unit>> signOut();
  User? get currentUser;
}

// features/auth/data/repositories/auth_repository_impl.dart
class AuthRepositoryImpl implements AuthRepository {
  final FirebaseAuth _firebaseAuth;
  final GoogleSignIn _googleSignIn;
  
  AuthRepositoryImpl({
    FirebaseAuth? firebaseAuth,
    GoogleSignIn? googleSignIn,
  })  : _firebaseAuth = firebaseAuth ?? FirebaseAuth.instance,
        _googleSignIn = googleSignIn ?? GoogleSignIn();
  
  @override
  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();
  
  @override
  Future<Either<Failure, User>> signInWithEmailAndPassword(
    String email,
    String password,
  ) async {
    try {
      final result = await _firebaseAuth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (result.user == null) {
        return const Left(AuthFailure('User not found'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, User>> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      if (googleUser == null) {
        return const Left(AuthFailure('Google sign-in cancelled'));
      }
      
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );
      
      final result = await _firebaseAuth.signInWithCredential(credential);
      
      if (result.user == null) {
        return const Left(AuthFailure('Failed to sign in with Google'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, User>> signUp(String email, String password) async {
    try {
      final result = await _firebaseAuth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      
      if (result.user == null) {
        return const Left(AuthFailure('Failed to create user'));
      }
      
      return Right(result.user!);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  Future<Either<Failure, Unit>> signOut() async {
    try {
      await Future.wait([
        _firebaseAuth.signOut(),
        _googleSignIn.signOut(),
      ]);
      return const Right(unit);
    } on FirebaseAuthException catch (e) {
      return Left(_mapAuthError(e));
    }
  }
  
  @override
  User? get currentUser => _firebaseAuth.currentUser;
  
  Failure _mapAuthError(FirebaseAuthException e) {
    switch (e.code) {
      case 'user-not-found':
        return const AuthFailure('No user found with this email');
      case 'wrong-password':
        return const AuthFailure('Incorrect password');
      case 'email-already-in-use':
        return const AuthFailure('Email is already registered');
      case 'invalid-email':
        return const AuthFailure('Invalid email address');
      case 'weak-password':
        return const AuthFailure('Password is too weak');
      default:
        return AuthFailure(e.message ?? 'Authentication error');
    }
  }
}

// features/auth/presentation/controllers/auth_controller.dart
@riverpod
class AuthController extends _$AuthController {
  @override
  Stream<User?> build() {
    final repository = ref.watch(authRepositoryProvider);
    return repository.authStateChanges;
  }
  
  Future<void> signInWithEmailAndPassword(String email, String password) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final result = await repository.signInWithEmailAndPassword(email, password);
      return result.fold(
        (failure) => throw failure,
        (user) => user,
      );
    });
  }
  
  Future<void> signInWithGoogle() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final result = await repository.signInWithGoogle();
      return result.fold(
        (failure) => throw failure,
        (user) => user,
      );
    });
  }
  
  Future<void> signOut() async {
    final repository = ref.read(authRepositoryProvider);
    await repository.signOut();
  }
}
```

---

### 3. Cloud Firestore CRUD

**Description:** Implementasi Firestore untuk database dengan real-time updates.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Firestore Service:**
   - CRUD operations
   - Real-time stream queries
   - Batch writes
   - Transactions

2. **Repository Pattern:**
   - Abstract contract
   - Firestore implementation
   - Offline persistence

3. **Security Rules:**
   - Basic read/write rules
   - User authentication rules
   - Data validation

**Output Format:**
```dart
// features/product/data/datasources/product_remote_ds.dart
abstract class ProductRemoteDataSource {
  Stream<List<ProductModel>> getProducts();
  Future<ProductModel> getProductById(String id);
  Future<ProductModel> createProduct(ProductModel product);
  Future<ProductModel> updateProduct(ProductModel product);
  Future<void> deleteProduct(String id);
}

// features/product/data/datasources/product_firestore_ds.dart
class ProductFirestoreDataSource implements ProductRemoteDataSource {
  final FirebaseFirestore _firestore;
  
  ProductFirestoreDataSource({FirebaseFirestore? firestore})
      : _firestore = firestore ?? FirebaseFirestore.instance;
  
  CollectionReference get _productsCollection => 
      _firestore.collection('products');
  
  @override
  Stream<List<ProductModel>> getProducts() {
    return _productsCollection
        .orderBy('createdAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs
            .map((doc) => ProductModel.fromJson(
                  doc.data() as Map<String, dynamic>,
                ).copyWith(id: doc.id))
            .toList());
  }
  
  @override
  Future<ProductModel> getProductById(String id) async {
    final doc = await _productsCollection.doc(id).get();
    if (!doc.exists) {
      throw NotFoundException('Product not found');
    }
    return ProductModel.fromJson(doc.data() as Map<String, dynamic>)
        .copyWith(id: doc.id);
  }
  
  @override
  Future<ProductModel> createProduct(ProductModel product) async {
    final docRef = await _productsCollection.add({
      'name': product.name,
      'price': product.price,
      'description': product.description,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
    });
    
    return product.copyWith(id: docRef.id);
  }
  
  @override
  Future<ProductModel> updateProduct(ProductModel product) async {
    await _productsCollection.doc(product.id).update({
      'name': product.name,
      'price': product.price,
      'description': product.description,
      'updatedAt': FieldValue.serverTimestamp(),
    });
    
    return product;
  }
  
  @override
  Future<void> deleteProduct(String id) async {
    await _productsCollection.doc(id).delete();
  }
}

// Controller dengan real-time stream
@riverpod
class ProductController extends _$ProductController {
  @override
  Stream<List<Product>> build() {
    final repository = ref.watch(productRepositoryProvider);
    return repository.watchProducts();
  }
  
  Future<void> addProduct({
    required String name,
    required double price,
    String? description,
  }) async {
    final repository = ref.read(productRepositoryProvider);
    final result = await repository.createProduct(Product(
      id: '',
      name: name,
      price: price,
      description: description,
      createdAt: DateTime.now(),
    ));
    
    result.fold(
      (failure) => throw failure,
      (_) {},
    );
  }
}

// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Products collection
    match /products/{productId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.name is string &&
        request.resource.data.price is number;
      allow update: if isAuthenticated() &&
        request.resource.data.updatedAt == request.time;
      allow delete: if isAuthenticated();
    }
    
    // Users collection
    match /users/{userId} {
      allow read: if isAuthenticated() && isOwner(userId);
      allow write: if isAuthenticated() && isOwner(userId);
    }
  }
}
```

---

### 4. Firebase Storage

**Description:** File upload dan download dengan progress tracking.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Upload Service:**
   - Image upload with compression
   - Progress tracking
   - Error handling

2. **Download Service:**
   - Get download URL
   - Cache management

**Output Format:**
```dart
// core/storage/firebase_storage_service.dart
class FirebaseStorageService {
  final FirebaseStorage _storage;
  
  FirebaseStorageService({FirebaseStorage? storage})
      : _storage = storage ?? FirebaseStorage.instance;
  
  Future<Either<Failure, String>> uploadFile({
    required File file,
    required String path,
    void Function(double progress)? onProgress,
  }) async {
    try {
      final ref = _storage.ref().child(path);
      final uploadTask = ref.putFile(file);
      
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        final progress = snapshot.bytesTransferred / snapshot.totalBytes;
        onProgress?.call(progress);
      });
      
      await uploadTask;
      final downloadUrl = await ref.getDownloadURL();
      
      return Right(downloadUrl);
    } on FirebaseException catch (e) {
      return Left(StorageFailure(e.message ?? 'Upload failed'));
    }
  }
  
  Future<Either<Failure, String>> uploadImage({
    required File imageFile,
    required String folder,
    int quality = 85,
    void Function(double progress)? onProgress,
  }) async {
    try {
      // Compress image
      final compressedFile = await FlutterImageCompress.compressWithFile(
        imageFile.absolute.path,
        quality: quality,
      );
      
      if (compressedFile == null) {
        return const Left(StorageFailure('Failed to compress image'));
      }
      
      final tempDir = await getTemporaryDirectory();
      final tempFile = File('${tempDir.path}/${DateTime.now().millisecondsSinceEpoch}.jpg');
      await tempFile.writeAsBytes(compressedFile);
      
      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${folder}.jpg';
      final path = '$folder/$fileName';
      
      return uploadFile(
        file: tempFile,
        path: path,
        onProgress: onProgress,
      );
    } catch (e) {
      return Left(StorageFailure(e.toString()));
    }
  }
  
  Future<Either<Failure, Unit>> deleteFile(String url) async {
    try {
      final ref = _storage.refFromURL(url);
      await ref.delete();
      return const Right(unit);
    } on FirebaseException catch (e) {
      return Left(StorageFailure(e.message ?? 'Delete failed'));
    }
  }
}

// Usage in controller
@riverpod
class ImageUploadController extends _$ImageUploadController {
  @override
  FutureOr<void> build() {}
  
  Future<String?> uploadProfileImage(File imageFile) async {
    state = const AsyncValue.loading();
    
    final storageService = ref.read(firebaseStorageServiceProvider);
    final user = ref.read(authControllerProvider).valueOrNull;
    
    if (user == null) return null;
    
    final result = await storageService.uploadImage(
      imageFile: imageFile,
      folder: 'profile_images/${user.uid}',
      onProgress: (progress) {
        // Update progress UI
      },
    );
    
    state = await AsyncValue.guard(() async {
      return result.fold(
        (failure) => throw failure,
        (url) => url,
      );
    });
    
    return state.valueOrNull as String?;
  }
}
```

---

### 5. Firebase Cloud Messaging (FCM)

**Description:** Push notifications dengan FCM.

**Recommended Skills:** `senior-flutter-developer`, `senior-firebase-developer`

**Instructions:**
1. **Setup FCM:**
   - Configure Android & iOS
   - Request permissions
   - Handle foreground/background messages

2. **Notification Service:**
   - Local notifications (flutter_local_notifications)
   - Navigate on notification tap
   - Data messages handling

**Output Format:**
```dart
// core/notifications/fcm_service.dart
class FCMService {
  final FirebaseMessaging _messaging;
  final FlutterLocalNotificationsPlugin _localNotifications;
  
  FCMService({
    FirebaseMessaging? messaging,
    FlutterLocalNotificationsPlugin? localNotifications,
  })  : _messaging = messaging ?? FirebaseMessaging.instance,
        _localNotifications = localNotifications ?? FlutterLocalNotificationsPlugin();
  
  Future<void> initialize() async {
    // Request permissions
    await _requestPermissions();
    
    // Initialize local notifications
    await _initializeLocalNotifications();
    
    // Handle foreground messages
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    
    // Handle background/terminated messages
    FirebaseMessaging.onMessageOpenedApp.listen(_handleNotificationTap);
    
    // Get initial message (if app opened from terminated state)
    final initialMessage = await _messaging.getInitialMessage();
    if (initialMessage != null) {
      _handleNotificationTap(initialMessage);
    }
    
    // Get FCM token
    final token = await _messaging.getToken();
    print('FCM Token: $token');
  }
  
  Future<void> _requestPermissions() async {
    await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );
  }
  
  Future<void> _initializeLocalNotifications() async {
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings();
    
    const initSettings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );
    
    await _localNotifications.initialize(
      initSettings,
      onDidReceiveNotificationResponse: (details) {
        // Handle notification tap
      },
    );
  }
  
  void _handleForegroundMessage(RemoteMessage message) {
    final notification = message.notification;
    if (notification != null) {
      _showLocalNotification(
        title: notification.title ?? 'New Notification',
        body: notification.body ?? '',
        payload: message.data.toString(),
      );
    }
  }
  
  void _handleNotificationTap(RemoteMessage message) {
    final data = message.data;
    final route = data['route'];
    final id = data['id'];
    
    // Navigate based on notification data
    if (route != null) {
      // Use GoRouter to navigate
    }
  }
  
  Future<void> _showLocalNotification({
    required String title,
    required String body,
    String? payload,
  }) async {
    const androidDetails = AndroidNotificationDetails(
      'default_channel',
      'Default Channel',
      importance: Importance.max,
      priority: Priority.high,
    );
    
    const iosDetails = DarwinNotificationDetails();
    
    const details = NotificationDetails(
      android: androidDetails,
      iOS: iosDetails,
    );
    
    await _localNotifications.show(
      DateTime.now().millisecond,
      title,
      body,
      details,
      payload: payload,
    );
  }
  
  Future<String?> getToken() => _messaging.getToken();
  
  Stream<String> get onTokenRefresh => _messaging.onTokenRefresh;
}

// Background message handler (must be top-level function)
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  // Handle background message
}
```

## Workflow Steps

1. **Setup Firebase Project**
   - Create Firebase project di console
   - Register Android & iOS apps
   - Download config files (google-services.json, GoogleService-Info.plist)
   - Install FlutterFire CLI
   - Run `flutterfire configure`

2. **Configure Dependencies**
   - Add Firebase packages ke pubspec.yaml
   - Initialize Firebase di main.dart
   - Setup platform-specific config (AndroidManifest, AppDelegate)

3. **Implement Authentication**
   - Setup Firebase Auth
   - Implement email/password login
   - Add Google Sign-In
   - Create auth repository dan controller

4. **Setup Firestore**
   - Design data structure
   - Create security rules
   - Implement CRUD operations
   - Setup real-time streams

5. **Configure Storage**
   - Setup Firebase Storage rules
   - Implement file upload dengan progress
   - Add image compression
   - Handle download URLs

6. **Setup FCM**
   - Configure push notifications
   - Request permissions
   - Handle foreground/background messages
   - Setup local notifications

7. **Test Integration**
   - Test authentication flows
   - Test Firestore operations
   - Test file upload/download
   - Test push notifications
   - Verify security rules

## Success Criteria

- [ ] Firebase project configured untuk semua platforms
- [ ] Authentication berfungsi (email/password & Google)
- [ ] Auth state stream implemented
- [ ] Firestore CRUD operations berfungsi
- [ ] Real-time updates dengan streams berfungsi
- [ ] Security rules configured dan tested
- [ ] File upload dengan progress tracking berfungsi
- [ ] Push notifications received di foreground & background
- [ ] Local notifications displayed correctly
- [ ] Offline persistence enabled

## Security Best Practices

### Firestore Rules
```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isValidString(field, maxLength) {
      return field is string && field.size() > 0 && field.size() <= maxLength;
    }
    
    // Always validate data
    match /products/{productId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() 
        && isValidString(request.resource.data.name, 100)
        && request.resource.data.price is number
        && request.resource.data.price >= 0;
      allow update: if isAuthenticated() && isOwner(resource.data.ownerId);
      allow delete: if isAuthenticated() && isOwner(resource.data.ownerId);
    }
  }
}
```

### Storage Rules
```
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /profile_images/{userId}/{allPaths=**} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
  }
}
```

## Next Steps

Setelah Firebase integration selesai:
1. Add Supabase integration untuk alternative backend
2. Implement comprehensive testing dengan Firebase emulators
3. Setup analytics tracking (Firebase Analytics)
4. Add crash reporting (Firebase Crashlytics)
5. Implement remote config (Firebase Remote Config)
